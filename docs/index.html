<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Slides Template</title>
        <link rel="stylesheet" href="./css/reveal.css">
        <link rel="stylesheet" href="./css/theme/black.css" id="theme">
        <link rel="stylesheet" href="./css/highlight/zenburn.css">
        <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print">

    </head>
    <body>

        <div class="reveal">
            <div class="slides"><section  data-markdown><script type="text/template">

## Asynchronous React

Kartseva Anastasia

Aston Lab

</script></section><section  data-markdown><script type="text/template">
#### План доклада

1. Очень кратко об асинхронности в JS

2. Асинхронность в реализации React Hooks

  *  Хук useState и асинхронное обновление состояния
  * Асинхронная функция внутри хука useEffect

3. Обработка асинхронных запросов в React

4. Конкуррентный режим и React.Suspense
</script></section><section  data-markdown><script type="text/template">

### Event Loop

<img src="images/eventloop.png" alt='Event loop image'/>

</script></section><section  data-markdown><script type="text/template">

### useState

```
const MyComponent = () => {
  const [state, setState] = useState('prev');
  const handleClick = () => {
    setState('next');
    console.log(state); // 'prev'
  };

  // setState is async!

  useEffect(() => {
    console.log(state); // 'next'
  }, [state]);
};

```

</script></section><section  data-markdown><script type="text/template">
### Batch of state updates

```
export default function App() {
  const [counter1, setCounter1] = useState(0); // 1
  const [counter2, setCounter2] = useState(0); // 1
  const [counter3, setCounter3] = useState(0); // 1
  const [renderCount, setRenderCount] = useState(0); // 1

  useEffect(() => {
    setRenderCount(renderCount + 1);
  }, [counter1, counter2, counter3]);

  const handleClick = () => {
    setCounter1(counter1 + 1);
    setCounter2(counter2 + 1);
    setCounter3(counter3 + 1);
  }

  return (
    <div className='App'>
      <h1>Function Component</h1>
      <div>
        Counter1: {counter1}
      </div>
      <div>
        Counter2: {counter2}
      </div>
      <div>
        Counter3: {counter3}
      </div>
      <br/>
      <div>Component was rendered {renderCount} times</div>
      <button onClick={handleClick}>Click me</button>
    </div>
  );
}

```

</script></section><section  data-markdown><script type="text/template">
### React 18: Automatic Batching

```
  async function handleChange(evt) {
    const name = evt.target.value;
    const response = await fetch('//some.url', JSON.stringify({ value })) // Api call that calculates the length and returns the value
    setName(v => name) // Does not re-render
    setLength(c => response.value) // Does not re-render
  }
```

</script></section><section  data-markdown><script type="text/template">
### useEffect callback: incorrect

```
  // Warning: Effect callbacks are synchronous to prevent race conditions

  useEffect(async () => {
    const products = await fetch(`${API_URL}/products.json`);
    setProducts(products);
  }, []);
```
</script></section><section  data-markdown><script type="text/template">

### useEffect callback: correct

```
  useEffect(() => {
    const fetchData = async () => {
      const products = await fetch(`${API_URL}/products.json`);
      setProducts(products);
    });

    fetchData();
  }, []);

  OR
  // IIFE
  useEffect(() => (async () => {
    const products = await fetch(`${API_URL}/products.json`);
      setProducts(products);
    })();
  }, []);

```

</script></section><section  data-markdown><script type="text/template">
#### Handling async requests in React

```
  const [items, setItems] = useState([]); // empty array
  useEffect(
    // ... async request and state update
  )

  return (
    <div>
      {items.map(...)} // renders nothing
    </div>
  )
```

</script></section><section  data-markdown><script type="text/template">

#### Handling async requests in React
###### “fetch-on-render”
```
  const [items, setItems] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  useEffect(() => {
    // ... async request and state update
    setIsLoading(false);
  }, []);

  return (
    <div>
      {isLoading ? <p>Загрузка...</p> : items.map(...) }
    </div>
  )
```

</script></section><section  data-markdown><script type="text/template">
#### Handling async requests in React
##### “fetch-on-render”
```
  const [loadState, setLoadState] = useState('idle');

  useEffect(() => {
    setLoadState('loading');
    const fetchData = async () => {
      try {
        const data = await fetch(...);
        setLoadState('success');
      } catch (err) {
        setLoadState('fail');
      }
    };
    fetchData();
  }, []);

```
</script></section><section  data-markdown><script type="text/template">
```
  ...
  const renderContent = () => {
    switch(loadState) {
      case 'loading':
        return <p>Загрузка...</p>;
      case 'fail':
        return <p>Что-то пошло не так!</p>;
      case 'success':
        return items.map(...);
      case 'idle':
      default:
        return null;
    }
  }

  return (
    <div>{ renderContent() }</div>
  );
```
</script></section><section  data-markdown><script type="text/template">
### React.Suspense
### waiting for promise to resolve

```
  function handleClick() {
    setTab('comments'); // setter is async
  }

  <Suspense fallback={<Spinner />}>
    {tab === 'photos' ? <Photos /> : <Comments />}
  </Suspense>

```
</script></section><section  data-markdown><script type="text/template">

### React.Suspense
### Concurrent mode 

  ```
  const [isPending, startTransition] = useTransition();

  function handleClick() {
    startTransition(() => {
      setTab('comments');
    });
  }

  <Suspense fallback={<Spinner />}>
    <div style={{ opacity: isPending ? 0.8 : 1 }}>
      {tab === 'photos' ? <Photos /> : <Comments />}
    </div>
  </Suspense>

  ```
</script></section><section ><section data-markdown><script type="text/template">
### React.Suspense for data fetching
#### Render-as-you-fetch

future React updates
```
  const todos = fetchData('/todos')

  return (
    <Suspense fallback={<Spinner />}>
      <Todos data={todos} />
    </Suspense>
  ) // tracking async request

```
</script></section><section data-markdown><script type="text/template">

### Links
* [Async useState](https://dev.to/fidalmathew/usestate-is-asynchronous-learn-how-to-use-usestate-and-useeffect-properly-1m1m)
* [Automnatic Batching](https://blog.devgenius.io/react-18-automatic-batching-2f5d691b4f19)
* [useEffect callback](https://www.designcise.com/web/tutorial/why-cant-react-useeffect-callback-be-async)
* [useEffect callback](https://www.designcise.com/web/tutorial/does-javascript-async-function-implicitly-return-a-promise)
* [Async requests handling](https://www.clearpeople.com/blog/how-to-handle-asynchronous-requests-gracefully-in-react)
* [Concurrent Mode in React](https://www.telerik.com/blogs/concurrent-mode-react)
* [React.Suspense new features](https://blog.logrocket.com/react-suspense-data-fetching/)
</script></section></section></div>
        </div>

        <script src="./lib/js/head.min.js"></script>
        <script src="./js/reveal.js"></script>

        <script>
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }

            // Optional libraries used to extend on reveal.js
            var deps = [
              { src: './lib/js/classList.js', condition: function() { return !document.body.classList; } },
              { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: './plugin/zoom-js/zoom.js', async: true },
              { src: './plugin/notes/notes.js', async: true },
              { src: './plugin/math/math.js', async: true }
            ];

            // default options to init reveal.js
            var defaultOptions = {
              controls: true,
              progress: true,
              history: true,
              center: true,
              transition: 'default', // none/fade/slide/convex/concave/zoom
              dependencies: deps
            };

            // options from URL query string
            var queryOptions = Reveal.getQueryHash() || {};

            var options = {"transition":"fade"};
            options = extend(defaultOptions, options, queryOptions);
        </script>


        <script>
            Reveal.initialize(options);
        </script>
    </body>
</html>
